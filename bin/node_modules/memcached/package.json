{
  "name": "memcached",
  "version": "0.2.8",
  "author": {
    "name": "Arnout Kazemier"
  },
  "description": "A fully featured Memcached API client, supporting both single and clustered Memcached servers through consistent hashing and failover/failure. Memcached is rewrite of nMemcached, which will be deprecated in the near future.",
  "main": "index",
  "keywords": [
    "InnoDB memcached API",
    "cache",
    "client",
    "cluster",
    "failover",
    "hashing",
    "membase",
    "memcache",
    "memcached",
    "nMemcached",
    "nosql"
  ],
  "maintainers": [
    {
      "name": "Arnout Kazemier",
      "email": "info@3rd-Eden.com",
      "url": "http://www.3rd-Eden.com"
    }
  ],
  "license": {
    "type": "MIT",
    "url": "http://github.com/3rd-Eden/node-memcached/blob/master/LICENSE"
  },
  "repository": {
    "type": "git",
    "url": "http://github.com/3rd-Eden/node-memcached.git"
  },
  "dependencies": {
    "hashring": "0.0.x",
    "jackpot": ">=0.0.6"
  },
  "devDependencies": {
    "mocha": "*",
    "should": "*",
    "pre-commit": "*"
  },
  "scripts": {
    "test": "./node_modules/.bin/mocha $(shell find test -name '*.test.js')"
  },
  "readme": "# Memcached [![Build Status](https://secure.travis-ci.org/3rd-Eden/node-memcached.png?branch=master)](http://travis-ci.org/3rd-Eden/node-memcached)\n\n`memcached` is a fully featured Memcached client for Node.js. `memcached` is\nbuild with scaling, high availability and exceptional performance in mind. We\nuse consistent hashing to store the data across different nodes. Consistent\nhashing is a scheme that provides a hash table functionality in a way that\nadding or removing a server node does not significantly change the mapping of\nthe keys to server nodes. The algorithm that is used for consistent hashing is\nthe same as `libketama`.\n\nThere are different ways to handle errors for example, when a server becomes\nunavailable you can configure the client to see all requests to that server as\ncache misses until it goes up again. It's also possible to automatically remove\nthe affected server from the consistent hashing algorithm or provide `memcached`\nwith a failover server that can take the place of the unresponsive server.\n\nWhen these issues occur the `memcached` client will emit different events where\nyou can subscribe to containing detailed information about the issues.\n\nThe client is configurable on different levels. There's a global configuration\nthat you update so all you Memcached clusters will use the same failure\nconfiguration for example, but it's also possible to overwrite these changes per\n`memcached` instance.\n\n### protocol\n\nThis module uses the ASCII protocol to communicate with the server, this makes\nit easier to debug for you are user as you can see what is send over the wire\nbut also for me as developer. But this also means that SASL auth is not\nsupported in this driver as that requires the use of the binary protocol. The\nASCII protocol not only used by memcached but also by other databases and\nmessage queues, so that is a nice extra.\n\n## Setting up the client\n\nThe constructor of the `memcached` client take 2 different arguments `server\nlocations` and `options`. Syntax:\n\n``` js\nvar Memcached = require('memcached');\nvar memcached = new Memcached(Server locations, options);\n```\n\n### Server locations\n\nThe server locations is designed to work with different formats. These formats\nare all internally parsed to the correct format so our consistent hashing scheme\ncan work with it. You can either use:\n\n1. **String**, this only works if you have are running a single server instance\n   of Memcached.  It's as easy a suppling a string in the following format:\n   `hostname:port`. For example `192.168.0.102:11212` This would tell the client\n   to connect to host `192.168.0.102` on port number `11212`.\n\n2. **Array**, if you are running a single server you would only have to supply\n  one item in the array.  The array format is particularly useful if you are\n  running a cluster of Memcached servers. This will allow you to spread the keys\n  and load between the different servers. Giving you higher availability for\n  when one of your Memcached servers goes down.\n\n3. **Object**, when you are running a cluster of Memcached servers it could\n   happen to not all server can allocate the same amount of memory. You might\n   have a Memcached server with 128mb, 512, 128mb. If you would the array\n   structure all servers would have the same weight in the consistent hashing\n   scheme. Spreading the keys 33/33/33 over the servers. But as server 2 has\n   more memory available you might want to give it more weight so more keys get\n   stored on that server. When you are using a object, the `key` should\n   represent the server location syntax and the value the weight of the server.\n   By default all servers have a weight of 1.  `{ '192.168.0.102:11212': 1,\n   '192.168.0.103:11212': 2, '192.168.0.104:11212': 1 }` would generate a\n   25/50/25 distribution of the keys.\n\nIf you would implement one of the above formats, your constructor would\nsomething like this:\n\n```js\nvar memcached = new Memcached({ '192.168.0.102:11212': 1, '192.168.0.103:11212': 2, '192.168.0.104:11212': 1 });\nvar memcached = new Memcached([ '192.168.0.102:11212', '192.168.0.103:11212', '192.168.0.104:11212' ]);\nvar memcached = new Memcached('192.168.0.102:11212');\n```\n\n### Options\n\nThere 2 kinds of options that can be configured. A global configuration that\nwill be inherited by all Memcached servers instances and a client specific\nconfiguration that can be used to overwrite the globals. The options should be\nformatted in an JavaScript `object`. They both use the same object structure:\n\n* `maxKeySize`: *250*, the max size of they key allowed by the Memcached server.\n* `maxExpiration`: *2592000*, the max expiration of keys by the Memcached server\n  in seconds.\n* `maxValue`: *1048576*, the max size of a value that is allowed by the\n  Memcached server.\n* `poolSize`: *10*, the maximum connections we can allocate in our connection pool.\n* `algorithm`: *crc32*, the hashing algorithm that should be used to generate\n  the hashRing values.\n* `reconnect`: *18000000*, when the server is marked as dead we will attempt to\n  reconnect every x milliseconds.\n* `timeout`: *5000*, after x ms the server should send a timeout if we can't\n  connect. This will also be used close the connection if we are idle.\n* `retries`: *5*, How many times to retry socket allocation for given request\n* `failures`: *5*, Number of times a server may have issues before marked dead.\n* `retry`: *30000*, time to wait between failures before putting server back in\n  service.\n* `remove`: *false*, when the server is marked as dead you can remove it from\n  the pool so all other will receive the keys instead.\n* `failOverServers`: *undefined*, the ability use these servers as failover when\n  the dead server get's removed from the consistent hashing scheme. This must be\n  an array of servers confirm the server_locations specification.\n* `keyCompression`: *true*, compress keys using md5 if they exceed the\n  maxKeySize option.\n* `idle`: *5000*, the idle timeout for the connections.\n\nExample usage:\n\n```js\nvar memcached = new Memcached('localhost:11212', {retries:10,retry:10000,remove:true,failOverServers:['192.168.0.103:11212']});\n```\n\nIf you wish to configure the options globally:\n\n```js\nvar Memcached = require('memcached');\n// all global configurations should be applied to the .config object of the Client.\nMemcached.config.poolSize = 25;\n```\n\n## API\n\n### Public methods\n\n#### memcached.touch(key, lifetime, callback);\n\nTouches the given key.\n\n**Arguments**\n\n`key`: **String** The key\n`lifetime`: **Number** After how long should the key expire measured in `seconds`\n`callback`: **Function**\n\n```js\nmemcached.touch('key', 10, function (err) {\n  // stuff\n});\n```\n\n#### memcached.get(key, callback);\n\nGet the value for the given key.\n\n**Arguments**\n\n`key`: **String**, the key\n`callback`: **Function**, the callback.\n\n```js\nmemcached.get('foo', function (err, data) {\n  console.log(data);\n});\n```\n\n#### memcached.gets(key, callback);\n\nGet the value and the CAS id.\n\n**Arguments**\n\n`key`: **String**, the key\n`callback`: **Function**, the callback.\n\n```js\nmemcached.gets('foo', function (err, data) {\n  console.log(data.foo);\n  console.log(data.cas);\n\n  // Please note that the data is stored under the name of the given key.\n});\n```\n\n#### memcached.getMulti(keys, callback);\n\nRetrieves a bunch of values from multiple keys.\n\n**Arguments**\n\n`keys`: **Array**, all the keys that needs to be fetched\n`callback`: **Function**, the callback.\n\n```js\nmemcached.getMulti(['foo', 'bar'], function (err, data) {\n  console.log(data.foo);\n  console.log(data.bar);\n});\n```\n\n#### memcached.set(key, value, lifetime, callback);\n\nStores a new value in Memcached.\n\n**Arguments**\n\n`key`: **String** the name of the key\n`value`: **Mixed** Either a buffer, JSON, number or string that you want to store.\n`lifetime`: **Number**, how long the data needs to be stored measured in `seconds`\n`callback`: **Function** the callback\n\n```js\nmemcached.set('foo', 'bar', 10, function (err) {\n  // stuff\n});\n```\n\n#### memcached.replace(key, value, lifetime, callback);\n\nReplaces the value in memcached. \n\n**Arguments**\n\n`key`: **String** the name of the key\n`value`: **Mixed** Either a buffer, JSON, number or string that you want to store.\n`lifetime`: **Number**, how long the data needs to be replaced measured in `seconds`\n`callback`: **Function** the callback\n\n```js\nmemcached.replace('foo', 'bar', 10, function (err) {\n  // stuff\n});\n```\n\n#### memcached.add(key, value, lifetime, callback);\n\nAdd the value, only if it's not in memcached already.\n\n**Arguments**\n\n`key`: **String** the name of the key\n`value`: **Mixed** Either a buffer, JSON, number or string that you want to store.\n`lifetime`: **Number**, how long the data needs to be replaced measured in `seconds`\n`callback`: **Function** the callback\n\n```js\nmemcached.add('foo', 'bar', 10, function (err) {\n  // stuff\n});\n```\n\n#### memcached.cas(key, value, cas, lifetime, callback);\n\nAdd the value, only if it matches the given CAS value.\n\n**Arguments**\n\n`key`: **String** the name of the key\n`value`: **Mixed** Either a buffer, JSON, number or string that you want to store.\n`lifetime`: **Number**, how long the data needs to be replaced measured in `seconds`\n`cas`: **String** the CAS value\n`callback`: **Function** the callback\n\n```js\nmemcached.gets('foo', function (err, data) {\n  memcached.cas('foo', 'bar', data.cas, 10, function (err) {\n    // stuff\n  });\n});\n```\n\n#### memcached.append(key, value, callback);\n\nAdd the given value string to the value of an existing item.\n\n**Arguments**\n\n`key`: **String** the name of the key\n`value`: **Mixed** Either a buffer, JSON, number or string that you want to store.\n`callback`: **Function** the callback\n\n```js\nmemcached.append('foo', 'bar', function (err) {\n  // stuff\n});\n```\n\n#### memcached.prepend(key, value, callback);\n\nAdd the given value string to the value of an existing item.\n\n**Arguments**\n\n`key`: **String** the name of the key\n`value`: **Mixed** Either a buffer, JSON, number or string that you want to store.\n`callback`: **Function** the callback\n\n```js\nmemcached.preprend('foo', 'bar', function (err) {\n  // stuff\n});\n```\n\n#### memcached.incr(key, amount, callback);\n\nIncrement a given key.\n\n**Arguments**\n\n`key`: **String** the name of the key\n`amount`: **Number** The increment\n`callback`: **Function** the callback\n\n```js\nmemcached.incr('foo', 10, function (err) {\n  // stuff\n});\n```\n\n#### memcached.decr(key, amount, callback);\n\nDecrement a given key.\n\n**Arguments**\n\n`key`: **String** the name of the key\n`amount`: **Number** The increment\n`callback`: **Function** the callback\n\n```js\nmemcached.incr('foo', 10, function (err) {\n  // stuff\n});\n```\n\n#### memcached.del(key, callback);\n\nRemove the key from memcached.\n\n**Arguments**\n\n`key`: **String** the name of the key\n`callback`: **Function** the callback\n\n```js\nmemcached.del('foo', function (err) {\n  // stuff\n});\n```\n\n#### memcached.version(callback);\n\nRetrieves the version number of your server.\n\n#### memcached.flush(callback);\n\nFlushes the memcached server.\n\n#### memcached.stats(callback);\n\nRetrieves stats from your memcached server.\n\n#### memcached.settings(callback);\n\nRetrieves your `stats settings`.\n\n#### memcached.slabs(callback);\n\nRetrieves `stats slabs` information.\n\n#### memcached.items(callback);\n\nRetrieves `stats items` information.\n\n#### memcached.cachedump(server, slabid, number, callback);\n\nInspect cache, see examples for a detailed explanation.\n\n#### memcached.end();\n\nCloses all active memcached connections.\n\n### Private methods\nThe following methods are intended for private usage:\n\n---------------------------------------\n#### .connect\nFetches or generates a connection for the given server. The supplied callback\nfunction will receive a reference to the connection as argument.\nIf there are issues with the server connection, we are going to respond with cache-miss pattern.\n\n**Arguments**\n\n`server`: *String*, The server that needs a connection, the format must be\nconfirm the server_locations specification.\n\n`callback`: *Function*, The callback function that receives the net.Stream\nconnection. It will be called with 2 arguments `error` and `connection`.\n\nExample:\n\n``` js\nmemcached.connect( '192.168.0.103:11212', function( err, conn ){\n  if( err ) throw new Error( err );\n  console.log( conn.server );\n});\n```\n\n---------------------------------------\n\n#### .multi\nA small wrapper function that makes it easier to query multiple Memcached\nservers. It will return the location for each key or the complete list of\nservers.\n\n**Arguments**\n\n`keys`: *Array* **(optional)**, They keys that needs to be converted to a server.\n\n`callback`: *Function*, The callback function for the data, it will be called\nfor **each** key. It will be called with 4 arguments:\n\n1. `server`: *String*, The server location.\n2. `key`: *String*, The key associated with the server, if you didn't specify\n   keys, this variable will be undefined.\n3. `index`: *Number*, The current index of the loop\n4. `total`: *Number*, The total amount server retrieved.\n\nExample:\n\n``` js\nmemcached.multi( false, function( server, key, index, totals ){\n  if( err ) throw new Error( err );\n\n  this.connect( server, function( err, conn ){\n    console.log( \"connection ready\" )\n  })\n});\n```\n\n---------------------------------------\n#### .command\n\nThis is the core functionality of the `memcached` client. All public API's are\nrouted through this function. It takes care of the argument validations Server\nretrieval ( If the server argument isn't specified ). After all data ready a\nconnection is asked for the private `connect` method and the command is written\nto the Memcached server.\n\n**Arguments**\n\n`query`: *Object*, The metaData object, see the `Callbacks` section for the\nspecification.\n\n`server`: *String*, The server the to connect. This is only needed when the\nmetaData object doesn't contain a key property to retrieve the server from.\n\nExample:\n\n``` js\nmemcached.command({\n  key: 'key', callback: function(){ console.dir( arguments ); },\n\n  // validate the arguments\n  validate: [[ 'key', String ], [ 'callback', Function ]],\n\n  // used for the query\n  type: 'delete',\n  command: 'delete key'\n});\n```\n\n---------------------------------------\n#### .connectionIssue\n\nA internal function for logging issues with connections. As there can be various\nof ways that an error occurs we need solid issue manager to handle all these\ncases. For example server could crash or the Memcached server could respond with\n`SERVER ERROR <broken>`.\n\n**Arguments**\n\n`error`: *String*, The actual error message.\n\n`Stream`: *net.Stream*, A reference to the connection stream where the error\noccurred on.\n\n`callback`: *Function* **(optional)**, The callback function of a potential\nrequest, it will be marked as cache miss if it was provided\n\nExample:\n\n``` js\nmemcached.connectionIssue( \"Server down\", connectionReference );\n```\n\n## Callbacks\n\nEach method requires a callback function. Once this function get executed there\nwill be 2 variables applied:\n\n* `error`: A error response if something went wrong while retrieving data from\n  the Memcached server. Depending on the type of request this will either be an\n  string or an Array with multiple errors.\n* `response`: The actual result from the Memcached server. If the response is\n  `false` or `undefined` than a cache miss occurred. Cache misses will also\n  occur when there is an error. So you might want to check on errors first.\n\nWhen we have a successful response, the context of the callback function will\nshift to a metaData object. The metaData object contains all information that we\nused to generate the request for the Memcached server. The metaData object\ncontains the following properties:\n\n* `start`: Date in milliseconds when the request was received\n* `execution`: Total execution time for the request, including response parsing.\n* `callback`: Reference to the callback function\n* `type`: The type of Memcached command\n* `command`: The compiled command that was send through the sockets\n* `validate`: The properties of metaData object that needs type validation.\n\nAnd all the arguments you have send to the method, this depends on the method\nyou have called.\n\n## Events\n\nWhen connection issues occur we send out different notifications using the\n`EventEmitter` protocol. This can be useful for logging, notification and\ndebugging purposes. Each event will receive details Object containing detailed\ninformation about the issues that occurred.\n\n### Details Object\n\nThe details Object contains the various of error messages that caused, the\nfollowing 3 will always be present in all error events:\n\n* `server`: the server where the issue occurred on\n* `tokens`: a array of the parsed server string in `[port, hostname]` format.\n* `messages`: a array containing all error messages that this server received.\n  As messages are added to the array using .push(), the first issue will at the\n  beginning and the latest error at the end of the array.\n\nThe following properties depend on the type of event that is send. If we are\nstill in our retry phase the details will also contain:\n\n* `failures`: the amount of failures left before we mark the server as dead.\n* `totalFailures`: the total amount of failures that occurred on this server, as when the\n  server has been reconnected after it's dead the `failures` will be rest to\n  defaults and messages will be removed.\n\nIf the server is dead these details will be added:\n\n* `totalReconnectsAttempted`: the total reconnects we have attempted. This is\nthe success and failure combined.\n* `totalReconnectsSuccess`: the total successful reconnects we have made.\n* `totalReconnectsFailed`: the total failed reconnects we have made.\n* `totalDownTime`: the total down time that was generated. Formula: (\n  totalReconnectsFailed * reconnect_timeout ) + ( totalRetries * retry_timeout).\n\n### Events\n\nThere are `5` different events that the `memcached` client emits when connection\nissues occur.\n\n* `issue`: a issue occurred on one a server, we are going to attempt a retry next.\n* `failure`: a server has been marked as failure or dead.\n* `reconnecting`: we are going to attempt to reconnect the to the failed server.\n* `reconnected`: successfully reconnected to the memcached server.\n* `remove`: removing the server from our consistent hashing.\n\nExample implementations:\n\n```js\nvar memcached = new Memcached([ '192.168.0.102:11212', '192.168.0.103:11212' ]);\nmemcached.on('failure', function( details ){ sys.error( \"Server \" + details.server + \"went down due to: \" + details.messages.join( '' ) ) });\nmemcached.on('reconnecting', function( details ){ sys.debug( \"Total downtime caused by server \" + details.server + \" :\" + details.totalDownTime + \"ms\")});\n```\n\n# Contributors\n\nThis project wouldn't be possible without the hard work of our amazing\ncontributors. See the contributors tab in Github for an up to date list of\n[contributors](/3rd-Eden/node-memcached/graphs/contributors).\n\nThanks for all your hard work on this project!\n\n# License\n\nThe driver is released under the MIT license. See the\n[LICENSE](/3rd-Eden/node-memcached/blob/master/LICENSE) for more information.\n",
  "_id": "memcached@0.2.8",
  "_from": "memcached@~0.2.8"
}
